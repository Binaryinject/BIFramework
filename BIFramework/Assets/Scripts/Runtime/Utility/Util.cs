using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;using UnityEngine.Events;using UnityEngine.EventSystems;using System;using System.Reflection;using DG.Tweening;using System.Linq;using System.IO;using System.Net.NetworkInformation;using System.Security.Cryptography;using System.Text;using System.Text.RegularExpressions;using DZen.BasE91;using UnityEngine.AddressableAssets;using UnityEngine.AI;using UnityEngine.ResourceManagement.ResourceLocations;using BIFramework;using Newtonsoft.Json;using Unity.Mathematics;using UnityEngine.Rendering.Universal;using XLua;using Object = UnityEngine.Object;using Random = UnityEngine.Random;[LuaCallCSharp]public enum RenderingMode {    Opaque,    Cutout,    Fade,    Transparent,}[LuaCallCSharp]public enum CropRectOptions {    Center,    BottomRight,    BottomLeft,    TopLeft,    TopRight,    Custom}[LuaCallCSharp]public static class MatrixUtils {    public static void Matrix4x4(this Transform transfrom, Matrix4x4 matrix4X4) {        transfrom.localScale = matrix4X4.GetScale();        transfrom.rotation = matrix4X4.GetRotation();        transfrom.position = matrix4X4.GetPostion();    }    public static Quaternion GetRotation(this Matrix4x4 matrix4X4) {        float qw = Mathf.Sqrt(1f + matrix4X4.m00 + matrix4X4.m11 + matrix4X4.m22) / 2;        float w = 4 * qw;        float qx = (matrix4X4.m21 - matrix4X4.m12) / w;        float qy = (matrix4X4.m02 - matrix4X4.m20) / w;        float qz = (matrix4X4.m10 - matrix4X4.m01) / w;        return new Quaternion(qx, qy, qz, qw);    }    public static Vector3 GetPostion(this Matrix4x4 matrix4X4) {        var x = matrix4X4.m03;        var y = matrix4X4.m13;        var z = matrix4X4.m23;        return new Vector3(x, y, z);    }    public static Vector3 GetScale(this Matrix4x4 m) {        var x = Mathf.Sqrt(m.m00 * m.m00 + m.m01 * m.m01 + m.m02 * m.m02);        var y = Mathf.Sqrt(m.m10 * m.m10 + m.m11 * m.m11 + m.m12 * m.m12);        var z = Mathf.Sqrt(m.m20 * m.m20 + m.m21 * m.m21 + m.m22 * m.m22);        return new Vector3(x, y, z);    }}[LuaCallCSharp]public static class Util {    public static Color Rainbow(float progress) {        progress = Mathf.Clamp01(progress);        float r = 0.0f;        float g = 0.0f;        float b = 0.0f;        int i = (int) (progress * 6);        float f = progress * 6.0f - i;        float q = 1 - f;        switch (i % 6) {            case 0:                r = 1;                g = f;                b = 0;                break;            case 1:                r = q;                g = 1;                b = 0;                break;            case 2:                r = 0;                g = 1;                b = f;                break;            case 3:                r = 0;                g = q;                b = 1;                break;            case 4:                r = f;                g = 0;                b = 1;                break;            case 5:                r = 1;                g = 0;                b = q;                break;        }        return new Color(r, g, b);    }    public static void SetupAIGraph(Vector3Int coordSize) {        var size = coordSize - Vector3Int.one;        AstarPath.active.data.layerGridGraph.center = new Vector3(0, -0.4f * size.y, 0);        AstarPath.active.data.layerGridGraph.SetDimensions(size.x * 4, size.z * 4, 0.1f);        AstarPath.active.data.layerGridGraph.Scan();    }    public static Mesh WeldVertices(Mesh aMesh, float aMaxDelta = 0.01f) {        var verts = aMesh.vertices;        var normals = aMesh.normals;        var uvs = aMesh.uv;        Dictionary<Vector3, int> duplicateHashTable = new Dictionary<Vector3, int>();        List<int> newVerts = new List<int>();        int[] map = new int[verts.Length];        //create mapping and find duplicates, dictionaries are like hashtables, mean fast        for (int i = 0; i < verts.Length; i++) {            if (!duplicateHashTable.ContainsKey(verts[i])) {                duplicateHashTable.Add(verts[i], newVerts.Count);                map[i] = newVerts.Count;                newVerts.Add(i);            }            else {                map[i] = duplicateHashTable[verts[i]];            }        }        // create new vertices        var verts2 = new Vector3[newVerts.Count];        var normals2 = new Vector3[newVerts.Count];        var uvs2 = new Vector2[newVerts.Count];        for (int i = 0; i < newVerts.Count; i++) {            int a = newVerts[i];            verts2[i] = verts[a];            normals2[i] = normals[a];            uvs2[i] = uvs[a];        }        // map the triangle to the new vertices        var tris = aMesh.triangles;        for (int i = 0; i < tris.Length; i++) {            tris[i] = map[tris[i]];        }        aMesh.triangles = tris;        aMesh.vertices = verts2;        aMesh.normals = normals2;        aMesh.uv = uvs2;        aMesh.RecalculateBounds();        aMesh.RecalculateNormals();        return aMesh;    }    public static string ByteConversionGBMBKB(long KSize) {        const int GB = 1024 * 1024 * 1024; //定义GB的计算常量        const int MB = 1024 * 1024; //定义MB的计算常量        const int KB = 1024; //定义KB的计算常量        if (KSize / GB >= 1) //如果当前Byte的值大于等于1GB            return Math.Round(KSize / (float) GB, 2) + "GB"; //将其转换成GB        if (KSize / MB >= 1) //如果当前Byte的值大于等于1MB            return Math.Round(KSize / (float) MB, 2) + "MB"; //将其转换成MB        if (KSize / KB >= 1) //如果当前Byte的值大于等于1KB            return Math.Round(KSize / (float) KB, 2) + "KB"; //将其转换成KGB        return KSize + "Byte"; //显示Byte值    }    public static void DrawWireSemicircle(Vector3 origin, Vector3 direction, float radius, float angle) {        DrawWireSemicircle(origin, direction, radius, angle, Vector3.up);    }    public static void DrawWireSemicircle(Vector3 origin, Vector3 direction, float radius, float angle, Vector3 axis) {        Vector3 leftdir = Quaternion.AngleAxis(-angle / 2, axis) * direction;        Vector3 rightdir = Quaternion.AngleAxis(angle / 2, axis) * direction;        Vector3 currentP = origin + leftdir * radius;        Vector3 oldP;        if (angle != 360) {            Gizmos.DrawLine(origin, currentP);        }        for (int i = 0; i < angle / 10; i++) {            Vector3 dir = Quaternion.AngleAxis(10 * i, axis) * leftdir;            oldP = currentP;            currentP = origin + dir * radius;            Gizmos.DrawLine(oldP, currentP);        }        oldP = currentP;        currentP = origin + rightdir * radius;        Gizmos.DrawLine(oldP, currentP);        if (angle != 360) {            Gizmos.DrawLine(currentP, origin);        }    }    public static bool AddressableResourceExists(object key, Type type) {        return Addressables.ResourceLocators.Any(l => l.Locate(key, type, out _));    }    public static Mesh SemicircleMesh(float radius, float angle, Vector3 axis) {        Vector3 leftdir = Quaternion.AngleAxis(-angle / 2, axis) * Vector3.forward;        Vector3 rightdir = Quaternion.AngleAxis(angle / 2, axis) * Vector3.forward;        int pcount = (int) (angle / 10);        //顶点        Vector3[] vertexs = new Vector3[3 + pcount];        vertexs[0] = Vector3.zero;        int index = 1;        vertexs[index] = leftdir * radius;        index++;        for (int i = 0; i < pcount; i++) {            Vector3 dir = Quaternion.AngleAxis(10 * i, axis) * leftdir;            vertexs[index] = dir * radius;            index++;        }        vertexs[index] = rightdir * radius;        //三角面        var triangles = new int[3 * (1 + pcount)];        for (int i = 0; i < 1 + pcount; i++) {            triangles[3 * i] = 0;            triangles[3 * i + 1] = i + 1;            triangles[3 * i + 2] = i + 2;        }        Mesh mesh = new Mesh();        mesh.vertices = vertexs;        mesh.triangles = triangles;        mesh.RecalculateNormals();        return mesh;    }    // Get Random Point on a Navmesh surface    public static Vector3 GetRandomPoint(Vector3 center, float maxDistance) {        // Get Random Point inside Sphere which position is center, radius is maxDistance        Vector3 randomPos = Random.insideUnitSphere * maxDistance + center;        NavMeshHit hit; // NavMesh Sampling Info Container        // from randomPos find a nearest point on NavMesh surface in range of maxDistance        NavMesh.SamplePosition(randomPos, out hit, maxDistance, NavMesh.AllAreas);        return hit.position;    }    public static Texture2D CropWithRect(CropRectOptions rectOptions, Texture2D texture, Rect r, int xMod, int yMod) {        if (r.height < 0 || r.width < 0) {            return texture;        }        Texture2D result = new Texture2D((int) r.width, (int) r.height);        if (r.width != 0 && r.height != 0) {            float xRect = r.x;            float yRect = r.y;            float widthRect = r.width;            float heightRect = r.height;            switch (rectOptions) {                case CropRectOptions.Center:                    xRect = (texture.width - r.width) / 2;                    yRect = (texture.height - r.height) / 2;                    break;                case CropRectOptions.BottomRight:                    xRect = texture.width - r.width;                    break;                case CropRectOptions.BottomLeft:                    break;                case CropRectOptions.TopLeft:                    yRect = texture.height - r.height;                    break;                case CropRectOptions.TopRight:                    xRect = texture.width - r.width;                    yRect = texture.height - r.height;                    break;                case CropRectOptions.Custom:                    float tempWidth = texture.width - r.width - xMod;                    float tempHeight = texture.height - r.height - yMod;                    xRect = tempWidth > texture.width ? 0 : tempWidth;                    yRect = tempHeight > texture.height ? 0 : tempHeight;                    break;            }            if (texture.width < r.x + r.width || texture.height < r.y + r.height || xRect > r.x + texture.width || yRect > r.y + texture.height || xRect < 0 ||                yRect < 0 || r.width < 0 || r.height < 0) {                //EditorUtility.DisplayDialog("Set value crop", "Set value crop (Width and Height > 0) less than origin texture size \n" + texture.name + " wrong size", "ReSet");                return texture;            }            result.SetPixels(texture.GetPixels(Mathf.FloorToInt(xRect), Mathf.FloorToInt(yRect), Mathf.FloorToInt(widthRect), Mathf.FloorToInt(heightRect)));            result.Apply();        }        return result;    }    public static bool GetPointIsInLine(Vector3 pf, Vector3 p1, Vector3 p2, int range = 1) {        return Vector3.Angle(p1 - p2, p1 - pf) <= range;    }    public static void ReplaceStandardShader(GameObject obj) {        var meshRender = obj.GetComponentsInChildren<MeshRenderer>(true);        foreach (MeshRenderer render in meshRender) {            if (render == null) continue;            for (int i = 0; i < render.sharedMaterials.Length; i++) {                var shaderName = render.sharedMaterials[i].shader.name;                if (shaderName == "Standard") {                    //render.sharedMaterials[i].shader = Shader.Find("Unlit/Color");                    //render.sharedMaterials[i].shader = Shader.Find("Standard");                    var mat = new Material(render.sharedMaterials[i]);                    mat.CopyPropertiesFromMaterial(render.sharedMaterials[i]);                    render.sharedMaterials[i] = mat;                }            }        }        var skinned = obj.GetComponentsInChildren<SkinnedMeshRenderer>(true);        foreach (SkinnedMeshRenderer render in skinned) {            if (render == null) continue;            for (int i = 0; i < render.sharedMaterials.Length; i++) {                var shaderName = render.sharedMaterials[i].shader.name;                if (shaderName == "Standard") {                    //render.sharedMaterials[i].shader = Shader.Find("Unlit/Color");                    //render.sharedMaterials[i].shader = Shader.Find("Standard");                    var mat = new Material(render.sharedMaterials[i]);                    mat.CopyPropertiesFromMaterial(render.sharedMaterials[i]);                    render.sharedMaterials[i] = mat;                }            }        }    }    public static void ReplaceRuntimeShader(GameObject obj) {#if UNITY_EDITOR        var mats = obj.GetComponentsInChildren<Renderer>(true);        foreach (Renderer mat in mats) {            if (mat.sharedMaterial == null) continue;            var shaderName = mat.sharedMaterial.shader.name;            var shaderInRuntime = Shader.Find(shaderName);            if (shaderInRuntime != null) {                mat.sharedMaterial.shader = shaderInRuntime;            }        }        var uis = obj.GetComponentsInChildren<Image>(true);        foreach (Image mat in uis) {            if (mat.material == null) continue;            var shaderName = mat.material.shader.name;            var shaderInRuntime = Shader.Find(shaderName);            if (shaderInRuntime != null) {                mat.material.shader = shaderInRuntime;            }        }        var raw = obj.GetComponentsInChildren<RawImage>(true);        foreach (RawImage mat in raw) {            if (mat.material == null) continue;            var shaderName = mat.material.shader.name;            var shaderInRuntime = Shader.Find(shaderName);            if (shaderInRuntime != null) {                mat.material.shader = shaderInRuntime;            }        }#endif    }    public static void ReplaceEditorShader(params Material[] mats) {#if UNITY_EDITOR        foreach (Material mat in mats) {            if (mat == null) continue;            var shaderName = mat.shader.name;            var shaderInRuntime = Shader.Find(shaderName);            if (shaderInRuntime != null) {                mat.shader = shaderInRuntime;                //Debug.Log($"[ReplaceEditorShader] Found the shader: {shaderName} used in mat: {mat.name}");            }            else {                //Debug.LogWarning($"[ReplaceEditorShader] Cant not find the shader: {shaderName} used in mat: {mat.name}");            }        }#endif    }    public static bool PullAndroidMarket(string channelPackage) {        try {            var uriClass = new AndroidJavaClass("android.net.Uri");            var Intent = new AndroidJavaClass("android.content.Intent");            var unityPlayer = new AndroidJavaClass("com.unity3d.player.UnityPlayer");            var currentActivity = unityPlayer.GetStatic<AndroidJavaObject>("currentActivity");            var javaObj = currentActivity.Call<AndroidJavaObject>("getPackageName");            var packageName = javaObj.Call<string>("toString");            var ACTION_VIEW = Intent.GetStatic<string>("ACTION_VIEW");            var FLAG_ACTIVITY_NEW_TASK = Intent.GetStatic<int>("FLAG_ACTIVITY_NEW_TASK");            var jstr_content = new AndroidJavaObject("java.lang.String", $"market://details?id={packageName}");            var uriObject = uriClass.CallStatic<AndroidJavaObject>("parse", jstr_content);            var intent = new AndroidJavaObject("android.content.Intent", ACTION_VIEW, uriObject);            intent.Call<AndroidJavaObject>("setPackage", channelPackage);            intent.Call<AndroidJavaObject>("addFlags", FLAG_ACTIVITY_NEW_TASK);            currentActivity.Call("startActivity", intent);            return true;        }        catch {            return false;        }    }    public static string GenResPath(long index) {        var div = 500L;        var arr = new List<long> {index % div};        if (index < div) {            index = 0;        }        while (true) {            if (index > div) {                arr.Add(div);                index = index / div;            }            else {                arr.Add(index);                index = 0;            }            if (arr.Count >= 5) break;        }        return $"images/{arr[4]}/{arr[3]}/{arr[2]}/{arr[1]}/{arr[0]}/";    }    public static void DelayInvoke(float time, UnityAction action) {        Sequence seq = DOTween.Sequence();        seq.AppendInterval(time);        seq.AppendCallback(() => { action(); });    }    public static void DelayInvoke(float time, UnityAction action, string id) {        DOTween.Kill(id);        Sequence seq = DOTween.Sequence();        seq.SetId(id);        seq.AppendInterval(time);        seq.AppendCallback(() => { action(); });    }    public static bool IsEquals(Vector3 v1, Vector3 v2, float Min = 0.0003f) {        if (Mathf.Abs(v1.x - v2.x) < Min && Mathf.Abs(v1.y - v2.y) < Min && Mathf.Abs(v1.z - v2.z) < Min) {            return true;        }        return false;    }    public static Texture2D Base64ToTexture2d(string Base64STR) {        Texture2D pic = new Texture2D(1, 1);        byte[] data = Convert.FromBase64String(Base64STR);        pic.LoadImage(data);        return pic;    }    public static string NumberToChinese(string num) {        string str = "";        switch (num) {            case "0":                str = "零";                break;            case "1":                str = "一";                break;            case "2":                str = "二";                break;            case "3":                str = "三";                break;            case "4":                str = "四";                break;            case "5":                str = "五";                break;            case "6":                str = "六";                break;            case "7":                str = "七";                break;            case "8":                str = "八";                break;            case "9":                str = "九";                break;        }        return str;    }    public static void MakeToast(string info) {#if UNITY_ANDROID        AndroidJavaClass unityPlayer = new AndroidJavaClass("com.unity3d.player.UnityPlayer");        AndroidJavaObject currentActivity = unityPlayer.GetStatic<AndroidJavaObject>("currentActivity");        AndroidJavaClass Toast = new AndroidJavaClass("android.widget.Toast");        currentActivity.Call("runOnUiThread",            new AndroidJavaRunnable(() => {                Toast.CallStatic<AndroidJavaObject>("makeText", currentActivity, info, Toast.GetStatic<int>("LENGTH_LONG")).Call("show");            }));#endif        /*        // 匿名方法中第二个参数是安卓上下文对象，除了用currentActivity，还可用安卓中的GetApplicationContext()获得上下文。        AndroidJavaObject context = currentActivity.Call<AndroidJavaObject>("getApplicationContext");        */    }    public static Color FixUiColor(Color col) {        if (QualitySettings.activeColorSpace == ColorSpace.Gamma)            return col;        float r = Mathf.GammaToLinearSpace(col.r);        float g = Mathf.GammaToLinearSpace(col.g);        float b = Mathf.GammaToLinearSpace(col.b);        float a = col.a;        return new Color(r, g, b, a);    }    /// <summary>    /// color 转换hex    /// </summary>    /// <param name="color"></param>    /// <returns></returns>    public static string ColorToHex(Color color, bool ignoreAlpha = true) {        int r = Mathf.RoundToInt(color.r * 255.0f);        int g = Mathf.RoundToInt(color.g * 255.0f);        int b = Mathf.RoundToInt(color.b * 255.0f);        int a = Mathf.RoundToInt(color.a * 255.0f);        string hex = ignoreAlpha ? $"{r:X2}{g:X2}{b:X2}" : $"{r:X2}{g:X2}{b:X2}{a:X2}";        return hex;    }    /// <summary>    /// hex转换到color    /// </summary>    /// <param name="hex"></param>    /// <returns></returns>    public static Color HexToColor(string hex, bool ignoreAlpha = true) {        byte br = byte.Parse(hex.Substring(0, 2), System.Globalization.NumberStyles.HexNumber);        byte bg = byte.Parse(hex.Substring(2, 2), System.Globalization.NumberStyles.HexNumber);        byte bb = byte.Parse(hex.Substring(4, 2), System.Globalization.NumberStyles.HexNumber);        float r = br / 255f;        float g = bg / 255f;        float b = bb / 255f;        float a = 1;        if (!ignoreAlpha) {            byte cc = byte.Parse(hex.Substring(6, 2), System.Globalization.NumberStyles.HexNumber);            a = cc / 255f;        }        return new Color(r, g, b, a);    }    public static string GetRelativePath(string path) {        return Application.dataPath.TrimEnd("Assets".ToCharArray()) + path;    }        public static string GetAssetPath(string path) {        return "Assets/" + path.TrimStart(Application.dataPath.ToCharArray());    }    public static void SmoothAmbientIntensity(Color intensity, float time) {        DOTween.To(() => RenderSettings.ambientLight, x => RenderSettings.ambientLight = x, intensity, time);    }    public static Vector2 GetAnchoredPosition(Vector3 pos, RectTransform rectCanvas) {        return GetAnchoredPosition(pos, rectCanvas, Vector2.zero);    }    public static Vector2 GetAnchoredPosition(Vector3 pos, RectTransform rectCanvas, Vector2 offset) {        Vector2 sizeDelta = rectCanvas.sizeDelta;        Vector3 vector = Camera.main.WorldToViewportPoint(pos);        Vector2 vector2 = new Vector2(vector.x - 0.5f, vector.y - 0.5f);        Vector2 v = new Vector2(vector2.x * sizeDelta.x, vector2.y * sizeDelta.y);        return v + offset;    }    public static void DebugVert(Vector3 v) {        Debug.Log(v.x + " : " + v.y + " : " + v.z);    }    public static List<object> PackParams(params object[] objs) {        return new(objs);    }    public static void SetLightData(Light lightObj, string data) {        var propety = data.Split('|');        string[] vec = propety[0].Split(',');        lightObj.transform.position = new Vector3(float.Parse(vec[0]), float.Parse(vec[1]), float.Parse(vec[2]));        vec = propety[1].Split(',');        lightObj.transform.eulerAngles = new Vector3(float.Parse(vec[0]), float.Parse(vec[1]), float.Parse(vec[2]));        lightObj.intensity = float.Parse(propety[2]);        vec = propety[3].Split(',');        lightObj.color = new Color(float.Parse(vec[0]), float.Parse(vec[1]), float.Parse(vec[2]), float.Parse(vec[3]));        lightObj.range = float.Parse(propety[4]);        if (propety.Length > 5) lightObj.spotAngle = float.Parse(propety[5]);        if (propety.Length > 6) lightObj.shadows = (LightShadows) float.Parse(propety[6]);        if (propety.Length > 7) lightObj.type = (LightType) float.Parse(propety[7]);    }    public static string AESEncrypt1(byte[] src, byte[] key, byte[] iv) {        using (var output = new MemoryStream()) {            Aes aes = AesCryptoServiceProvider.Create();            var encryptor = aes.CreateEncryptor(key, iv);            using (var cs = new CryptoStream(output, encryptor, CryptoStreamMode.Write)) {                cs.Write(src, 0, src.Length);            }            return Convert.ToBase64String(output.ToArray());        }    }    public static byte[] AESEncrypt2(byte[] src, byte[] key, byte[] iv) {        using (var output = new MemoryStream()) {            Aes aes = AesCryptoServiceProvider.Create();            var encryptor = aes.CreateEncryptor(key, iv);            using (var cs = new CryptoStream(output, encryptor, CryptoStreamMode.Write)) {                cs.Write(src, 0, src.Length);            }            return output.ToArray();        }    }    public static byte[] AESDecrypt2(byte[] src, byte[] key, byte[] iv) {        using (var output = new MemoryStream()) {            using (var input = new MemoryStream(src)) {                Aes aes = AesCryptoServiceProvider.Create();                var decryptor = aes.CreateDecryptor(key, iv);                using (var cs = new CryptoStream(input, decryptor, CryptoStreamMode.Read)) {                    cs.CopyTo(output);                }                return output.ToArray();            }        }    }    public static string AESDecrypt1(string str, byte[] key, byte[] iv) {        byte[] src = Convert.FromBase64String(str);        using (var output = new MemoryStream()) {            using (var input = new MemoryStream(src)) {                Aes aes = AesCryptoServiceProvider.Create();                var decryptor = aes.CreateDecryptor(key, iv);                using (var cs = new CryptoStream(input, decryptor, CryptoStreamMode.Read)) {                    cs.CopyTo(output);                }                return Encoding.Default.GetString(output.ToArray());            }        }    }    public static void TextLeftAndRightAlignment(Text text, string value, float maxWidth) {        text.text = "";        string[] end = null;        if (value.IndexOf('—') != -1)            end = value.Split('—');        if (end == null)            SetText(text, value, maxWidth);        else {            string str1 = SetText(text, end[0], maxWidth);            string str2 = "";            string str3 = "——" + end[2];            text.text = "";            while (text.preferredWidth < maxWidth) {                str2 += " ";                text.text = str2 + str3;            }            str2 = str2.Substring(0, str2.Length - 1);            text.text = str1 + "\n" + str2 + str3;        }    }    static string SetText(Text text, string value, float maxWidth) {        string[] ary = value.Split(' ');        string str1 = "";        string str2 = "";        for (int i = 0, count = ary.Length; i < count; ++i) {            str1 = str1 + ary[i] + " ";            text.text = str1;            if (text.preferredWidth > maxWidth) {                str1 = str1.Substring(0, str1.Length - ary[i].Length - 1);                i--;                str2 = str2 + str1 + "\n";                str1 = "";                text.text = str1;            }        }        if (str1 != "") str2 = str2 + str1;        text.text = str2;        return str2;    }    public static Vector3 ProjectPointOnPlane(Vector3 planeNormal, Vector3 planePoint, Vector3 point) {        float distance;        Vector3 translationVector;        //First calculate the distance from the point to the plane:        distance = SignedDistancePlanePoint(planeNormal, planePoint, point);        //Reverse the sign of the distance        distance *= -1;        //Get a translation vector        translationVector = SetVectorLength(planeNormal, distance);        //Translate the point to form a projection        return point + translationVector;    }    public static float SignedDistancePlanePoint(Vector3 planeNormal, Vector3 planePoint, Vector3 point) {        return Vector3.Dot(planeNormal, (point - planePoint));    }    public static Vector3 SetVectorLength(Vector3 vector, float size) {        //normalize the vector        Vector3 vectorNormalized = Vector3.Normalize(vector);        //scale the vector        return vectorNormalized *= size;    }    public static Vector3 GetCenterOfGravity(List<Vector3> vect3s) {        float minx = vect3s[0].x;        float maxx = vect3s[0].x;        float miny = vect3s[0].y;        float maxy = vect3s[0].y;        float minz = vect3s[0].z;        float maxz = vect3s[0].z;        for (int i = 0; i < vect3s.Count; i++) {            if (minx > vect3s[i].x) minx = vect3s[i].x;            if (maxx < vect3s[i].x) maxx = vect3s[i].x;            if (miny > vect3s[i].y) miny = vect3s[i].y;            if (maxy < vect3s[i].y) maxy = vect3s[i].y;            if (minz > vect3s[i].z) minz = vect3s[i].z;            if (maxz < vect3s[i].z) maxz = vect3s[i].z;        }        return new Vector3((minx + maxx) / 2, (miny + maxy) / 2, (minz + maxz) / 2);    }    // public static IEnumerator YieldAniFinish(Animator ani, string aniName, UnityAction action, int layer = 0,    //     float normalizedTime = 0.3f) {    //     yield return new WaitForEndOfFrame();    //     AnimatorStateInfo stateinfo = ani.GetCurrentAnimatorStateInfo(layer);    //     if (stateinfo.IsName(aniName) && (stateinfo.normalizedTime > normalizedTime)) action.Invoke();    //     else CoroutineMgr.StartCoroutine(YieldAniFinish(ani, aniName, action, layer, normalizedTime));    // }    public static Texture2D DuplicateTexture(Texture2D source) {        RenderTexture renderTex = RenderTexture.GetTemporary(source.width, source.height, 0, RenderTextureFormat.Default, RenderTextureReadWrite.Linear);        Graphics.Blit(source, renderTex);        RenderTexture previous = RenderTexture.active;        RenderTexture.active = renderTex;        Texture2D readableText = new Texture2D(source.width, source.height);        readableText.ReadPixels(new Rect(0, 0, renderTex.width, renderTex.height), 0, 0);        readableText.Apply();        RenderTexture.active = previous;        RenderTexture.ReleaseTemporary(renderTex);        return readableText;    }    public static bool NormalIsCut(Vector3 normal) {        return !((Mathf.Abs(normal.x) == 0 || Mathf.Abs(normal.x) == 1) && (Mathf.Abs(normal.y) == 0 || Mathf.Abs(normal.y) == 1) &&                 (Mathf.Abs(normal.z) == 0 || Mathf.Abs(normal.z) == 1));    }    // public static byte[] GeneQRCode(string str, int width = 256, int height = 256) {    //     Texture2D t = new Texture2D(width, height);    //     ZXing.QrCode.QrCodeEncodingOptions options = new ZXing.QrCode.QrCodeEncodingOptions();    //     options.CharacterSet = "UTF-8";    //     options.Width = width;    //     options.Height = height;    //     options.Margin = 1;    //     var barcodeWriter = new BarcodeWriter {Format = ZXing.BarcodeFormat.QR_CODE, Options = options};    //     t.SetPixels32(barcodeWriter.Write(str));    //     t.Apply();    //     return t.EncodeToPNG();    // }    //    // public static Texture2D GeneQRCodeTex2d(string str, int width = 256, int height = 256) {    //     // 实例化一个图片类    //     Texture2D t = new Texture2D(width, height);    //     QrCodeEncodingOptions options = new QrCodeEncodingOptions();    //     options.CharacterSet = "UTF-8";    //     options.Width = width;    //     options.Height = height;    //     options.Margin = 1;    //     var barcodeWriter = new BarcodeWriter {Format = BarcodeFormat.QR_CODE, Options = options};    //     t.SetPixels32(barcodeWriter.Write(str));    //     t.Apply();    //     return t;    // }    public static void SaveScreenShot(Camera cam, string savePath) {        var urpCameraData = cam.GetComponent<UniversalAdditionalCameraData>();        var wasPostprocessing = urpCameraData.renderPostProcessing;        var wasTargetTexture = cam.targetTexture;        var wasClearFlags = cam.clearFlags;        var wasActive = RenderTexture.active;        var width = Screen.width;        var height = Screen.height;        var transparentTexture = new Texture2D(width, height, TextureFormat.ARGB32, false);        var postprocessTexture = new Texture2D(width, height, TextureFormat.ARGB32, false);        var renderTexture = RenderTexture.GetTemporary(width, height, 24, RenderTextureFormat.ARGB32);        renderTexture.antiAliasing = 8;        var grabArea = new Rect(0, 0, width, height);        RenderTexture.active = renderTexture;        cam.targetTexture = renderTexture;        cam.clearFlags = CameraClearFlags.SolidColor;        cam.backgroundColor = Color.clear;        urpCameraData.renderPostProcessing = false;        cam.Render();        transparentTexture.ReadPixels(grabArea, 0, 0);        transparentTexture.Apply();        urpCameraData.renderPostProcessing = true;        cam.Render();        postprocessTexture.ReadPixels(grabArea, 0, 0);        postprocessTexture.Apply();        var transparentPixels = transparentTexture.GetPixels();        var postprocessPixels = postprocessTexture.GetPixels();        for (var i = 0; i < transparentPixels.Length; i++) {            if (postprocessPixels[i] == Color.black) {                postprocessPixels[i] = new Color(postprocessPixels[i].r, postprocessPixels[i].g, postprocessPixels[i].b, transparentPixels[i].a);            }        }        postprocessTexture.SetPixels(postprocessPixels);        byte[] pngShot = TextureUtility.ClipAlphaEdge(postprocessTexture).EncodeToPNG();        File.WriteAllBytes(savePath, pngShot);        cam.clearFlags = wasClearFlags;        cam.targetTexture = wasTargetTexture;        urpCameraData.renderPostProcessing = wasPostprocessing;        RenderTexture.active = wasActive;        RenderTexture.ReleaseTemporary(renderTexture);        Object.Destroy(transparentTexture);        Object.Destroy(postprocessTexture);        GC.Collect();        Resources.UnloadUnusedAssets();    }    /// <summary>    /// 计算MD5值    /// </summary>    /// <param name="buffer"></param>    /// <returns></returns>    public static string ComputeHash(byte[] buffer) {        if (buffer == null || buffer.Length < 1)            return "";        var md5 = MD5.Create();        byte[] hash = md5.ComputeHash(buffer);        StringBuilder sb = new StringBuilder();        foreach (var b in hash)            sb.Append(b.ToString("x2"));        return sb.ToString();    }    /// 获取字符串的总占位数(英文计1，其他计2)    public static int GetStringSize(string str) {        int len = 0;        foreach (var value in str) {            Match info = Regex.Match(value.ToString(), @"^[A-Za-z]+$");            if (!info.Success && !Char.IsNumber(value))                len++;            len++;        }        return len;    }    /// 剪切字符串（最终的字符串的真实位数不会超过给定的位数），字符位数(英文计1，其他计2)    public static string CutString(string str, int lenth) {        int len = 0;        string end = "";        foreach (var value in str) {            Match info = Regex.Match(value.ToString(), @"^[A-Za-z]+$");            if (!info.Success && !Char.IsNumber(value))                len++;            len++;            if (len > lenth) break;            end += value;        }        return end;    }    //获取字符串的MD5    public static string GetMD5HashFromString(string str) {        var md5 = new MD5CryptoServiceProvider();        var bytValue = System.Text.Encoding.UTF8.GetBytes(str);        var bytHash = md5.ComputeHash(bytValue);        md5.Clear();        string sTemp = "";        for (int i = 0; i < bytHash.Length; i++) {            sTemp += bytHash[i].ToString("X").PadLeft(2, '0');        }        return sTemp.ToUpper();    }    public static string GetMacAddress() {        string physicalAddress = "";        NetworkInterface[] nice = NetworkInterface.GetAllNetworkInterfaces();        foreach (NetworkInterface adaper in nice) {            if (adaper.Description == "en0") {                physicalAddress = adaper.GetPhysicalAddress().ToString();                break;            }            else {                physicalAddress = adaper.GetPhysicalAddress().ToString();                if (physicalAddress != "") {                    break;                }                ;            }        }        return physicalAddress;    }        // public static DevInfo GetDeviceInfo() {    //     JObject json = new JObject();    //     json["osVer"] = SystemInfo.operatingSystem;    //     json["terminInfo"] = SystemInfo.deviceModel;    //     json["media"] = "";    //     json["ip"] = Dns.GetHostAddresses(Dns.GetHostName())[0].ToString();    //     json["imei"] = SystemInfo.deviceUniqueIdentifier;    //     json["mac"] = GetMacAddress();    //     json["oaid"] = "";    //     return JsonMapper.ToObject<DevInfo>(json.ToJson());    // }}[LuaCallCSharp]public static class UnityMethodExtend {    public static T FindComponent<T>(this GameObject go, string path) {        if (go == null) {            Debug.LogError("Source object is null!");            return default(T);        }        return go.transform.Find(path).GetComponent<T>();    }    public static Object FindComponent(this GameObject go, Type type, string path) {        if (go == null) {            Debug.LogError("Source object is null!");            return null;        }        return go.transform.Find(path).GetComponent(type);    }    public static T FindComponent<T>(this Transform go, string path) {        if (go == null) {            Debug.LogError("Source transform is null!");            return default(T);        }        return go.Find(path).GetComponent<T>();    }    public static Object FindComponent(this Transform go, Type type, string path) {        if (go == null) {            Debug.LogError("Source transform is null!");            return null;        }        return go.Find(path).GetComponent(type);    }    public static void AddListener(this GameObject go, UnityAction action) {        Button btn = go.GetComponent<Button>();        if (go == null || btn == null) {            Debug.LogError("Button object is null!");            return;        }        btn.GetComponent<Button>().onClick.AddListener(action);    }    public static void AddListener(this Button btn, UnityAction action) {        if (btn == null) {            Debug.LogError("Button object is null!");            return;        }        btn.onClick.AddListener(action);    }    public static Vector3 ToVector3(this List<double> obj) {        if (obj.Count != 3) {            Debug.LogError("ToVector3 list count is:" + obj.Count);            return default(Vector3);        }        return new Vector3((float) obj[0], (float) obj[1], (float) obj[2]);    }    public static string ToGridString(this Vector3Int obj) {        return $"{obj.x}-{obj.y}-{obj.z}";    }    public static string ToStringVector3Int(this Vector3Int obj) {        return $"{obj.x},{obj.y},{obj.z}";    }    public static string ToStringVector3(this List<double> obj) {        if (obj.Count != 3) {            Debug.LogError("ToVector3 list count is:" + obj.Count);            return default(string);        }        return (float) obj[0] + "," + (float) obj[1] + "," + (float) obj[2];    }    public static string ToStringVector3(this Vector3 obj) {        return $"{obj.x},{obj.y},{obj.z}";    }    public static string ToStringSplit<T>(this List<T> lists) {        if (lists.Count == 0) return string.Empty;        if (lists.Count == 1) return lists[0].ToString();        var output = lists[0].ToString();        for (var i = 1; i < lists.Count; i++) {            output += $",{lists[i].ToString()}";        }        return output;    }    public static string ToStringAngle(this Transform obj) {        if (!obj) {            Debug.LogError("ToVector3 is null:" + obj.name);            return default(string);        }        Vector3 fix = obj.eulerAngles.FixedVector3();        return fix.x + "," + fix.y + "," + fix.z;    }    public static string ToStringPosition(this Transform obj) {        if (!obj) {            Debug.LogError("ToVector3 is null:" + obj.name);            return default(string);        }        Vector3 fix = obj.position.FixedVector3();        return fix.x + "," + fix.y + "," + fix.z;    }    public static string ToStringColor(this Color col) {        return col.r + "," + col.g + "," + col.b + "," + col.a;    }    public static Vector2 ToVector2(this Vector3 vec) {        return new(vec.x, vec.y);    }    public static float3 FixedFloat3(this float3 vec) {        return new(Round(vec.x), Round(vec.y), Round(vec.z));    }    public static Vector3 FixedVector3(this Vector3 vec) {        return new(Round(vec.x), Round(vec.y), Round(vec.z));    }    public static Vector3 FixedVector3(this Vector3 vec, int digit) {        return new(Round(vec.x, digit), Round(vec.y, digit), Round(vec.z, digit));    }    public static void FixedLocalVector3(this Transform transform) {        Vector3 pos = transform.localPosition;        transform.localPosition = new Vector3(Round(pos.x), Round(pos.y), Round(pos.z));    }    public static void FixedVector3(this Transform transform) {        Vector3 pos = transform.position;        transform.position = new Vector3(Round(pos.x), Round(pos.y), Round(pos.z));    }    public static List<double> ToDoubleArray(this string content) {        string[] tmp = content.Split(',');        List<double> list = new List<double>();        for (int i = 0; i < tmp.Length; i++) {            list.Add(double.Parse(tmp[i]));        }        return list;    }    public static float Round(float value, int digit = 4) {        return (float) Math.Round((decimal) value, digit, MidpointRounding.AwayFromZero);    }    public static void BindUIClick(this MonoBehaviour page, EventTriggerListener.VoidDelegate<PointerEventData> voidDelegate, ScrollRect rect,        bool monitor = false) {        Type type = page.GetType();        FieldInfo[] props = type.GetFields();        foreach (FieldInfo f in props) //遍历        {            if (f.FieldType.Namespace == "UnityEngine.UI" && f.DeclaringType.Equals(type) && f.IsPublic && f.FieldType == typeof(Button)) {                Type t = f.FieldType;                var value = f.GetValue(page) as Button;                if (value != null) {                    EventTriggerListener.Get(value.gameObject).onClick = voidDelegate;                    EventTriggerListener.Get(value.gameObject).onBeginDrag = rect.OnBeginDrag;                    EventTriggerListener.Get(value.gameObject).onDrag = rect.OnDrag;                    EventTriggerListener.Get(value.gameObject).onEndDrag = rect.OnEndDrag;                    if (monitor) MonitorButtonFX(value.transform);                }                else Debug.LogError("[<color=red>" + f.Name + "</color>] <" + f.FieldType + ">" + " is not find!");            }            else if (f.FieldType.Namespace == "System.Collections.Generic" && f.DeclaringType.Equals(type) && f.IsPublic && f.FieldType.IsGenericType &&                     f.FieldType.GetGenericArguments()[0] == typeof(Button)) {                Type t = f.FieldType;                var value = f.GetValue(page) as List<Button>;                if (value != null) {                    for (int i = 0; i < value.Count; i++) {                        EventTriggerListener.Get(value[i].gameObject).onClick = voidDelegate;                        EventTriggerListener.Get(value[i].gameObject).onBeginDrag = rect.OnBeginDrag;                        EventTriggerListener.Get(value[i].gameObject).onDrag = rect.OnDrag;                        EventTriggerListener.Get(value[i].gameObject).onEndDrag = rect.OnEndDrag;                        if (monitor) MonitorButtonFX(value[i].transform);                    }                }            }        }    }    public static void BindUIClick(this MonoBehaviour page, EventTriggerListener.VoidDelegate<PointerEventData> voidDelegate, bool monitor = true) {        Type type = page.GetType();        FieldInfo[] props = type.GetFields();        foreach (FieldInfo f in props) //遍历        {            if (f.FieldType.Namespace == "UnityEngine.UI" && f.DeclaringType.Equals(type) && f.IsPublic && f.FieldType == typeof(Button)) {                Type t = f.FieldType;                var value = f.GetValue(page) as Button;                if (value != null) {                    EventTriggerListener.Get(value.gameObject).onClick = voidDelegate;                    if (monitor) MonitorButtonFX(value.transform);                }                else Debug.LogError("[<color=red>" + f.Name + "</color>] <" + f.FieldType + ">" + " is not find!");            }            else if (f.FieldType.Namespace == "System.Collections.Generic" && f.DeclaringType.Equals(type) && f.IsPublic && f.FieldType.IsGenericType &&                     f.FieldType.GetGenericArguments()[0] == typeof(Button)) {                Type t = f.FieldType;                var value = f.GetValue(page) as List<Button>;                if (value != null) {                    for (int i = 0; i < value.Count; i++) {                        //Debug.Log(value[i].gameObject.name);                        EventTriggerListener.Get(value[i].gameObject).onClick = voidDelegate;                        if (monitor) MonitorButtonFX(value[i].transform);                    }                }            }        }    }    /// <summary>    /// 子对象坐标转换到Canvas的局部坐标    /// </summary>    /// <param name="current"></param>    /// <param name="canvas"></param>    /// <returns></returns>    public static Vector2 TransformToCanvasLocalPosition(this Transform current, Canvas canvas) {        var screenPos = canvas.worldCamera.WorldToScreenPoint(current.transform.position);        Vector2 localPos;        RectTransformUtility.ScreenPointToLocalPointInRectangle(canvas.GetComponent<RectTransform>(), screenPos, canvas.worldCamera, out localPos);        return localPos;    }    public static void SetNativeSize(this Button btn) {        Vector2 oldVec = btn.GetComponent<RectTransform>().sizeDelta;        btn.GetComponent<Image>().SetNativeSize();        Vector2 newVec = btn.GetComponent<RectTransform>().sizeDelta;        btn.GetComponent<RectTransform>().sizeDelta = oldVec;        btn.GetComponent<RectTransform>().DOSizeDelta(newVec, 0.3f);    }    public static List<string> GetAllClip(this Animation _ani) {        var _clips = new List<string>();        foreach (AnimationState _state in _ani) {            _clips.Add(_state.name);        }        return _clips;    }    public static IEnumerable<T> Distinct<T>(this IEnumerable<T> source, Func<T, T, bool> comparer) where T : class =>        source.Distinct(new DynamicEqualityComparer<T>(comparer));    private sealed class DynamicEqualityComparer<T> : IEqualityComparer<T> where T : class {        private readonly Func<T, T, bool> _func;        public DynamicEqualityComparer(Func<T, T, bool> func) {            _func = func;        }        public bool Equals(T x, T y) => _func(x, y);        public int GetHashCode(T obj) => 0;    }    public static string Format(this string str, params object[] args) {        return String.Format(str, args);    }    public static int ToInt(this string str) {        return int.Parse(str);    }    public static float ToFloat(this string str) {        return float.Parse(str);    }    public static Vector3 ToVector3(this Vector3Int vector) {        return vector;    }    public static Vector3 ToVector3(this string str) {        var vec = str.Split(',');        return new Vector3(float.Parse(vec[0]), float.Parse(vec[1]), float.Parse(vec[2]));    }    public static Vector3Int ToVector3Int(this string str) {        var vec = str.Split(',');        return new Vector3Int(int.Parse(vec[0]), int.Parse(vec[1]), int.Parse(vec[2]));    }    public static bool ListEquals<T>(this IEnumerable<T> one, IEnumerable<T> another) {        if (one.Count() != another.Count()) return false;        return (one.Except(another)).Count() == 0;    }    public static Vector2 ToPositionScaler(this Vector2 pos) {        var ratio = (float) Screen.height / (float) Screen.width;        var orgin = 1920f / 1080f;        float posScale = ratio / orgin;        var scale = new Vector2(pos.x * posScale, pos.y * posScale);        return scale;    }    public static RectTransform RectTransform(this Transform transform) {        var cmp = transform.GetComponent<RectTransform>();        return cmp;    }    public static RectTransform RectTransform(this GameObject go) {        var cmp = go.transform.GetComponent<RectTransform>();        return cmp;    }    public static RectTransform RectTransform(this Selectable go) {        var cmp = go.transform.GetComponent<RectTransform>();        return cmp;    }    public static string GetEulerString(this Quaternion quater) {        return Round(quater.eulerAngles.x, 1) + "," + Round(quater.eulerAngles.y, 1) + "," + Round(quater.eulerAngles.z, 1);    }    public static void UnMonitorButton(this Button value) {        UnMonitorButton(value.transform);    }    public static void UnMonitorButton(this GameObject value) {        UnMonitorButton(value.transform);    }    public static void UnMonitorButton(this Transform value) {        EventTriggerListener.Get(value.gameObject).onDown = null;        EventTriggerListener.Get(value.gameObject).onUp = null;    }    public static void MonitorButtonFX(this Button value, float threshold = 0) {        MonitorButtonFX(value.transform, threshold);    }    public static void MonitorButtonFX(this GameObject value, float threshold = 0) {        MonitorButtonFX(value.transform, threshold);    }    public static void MonitorButtonFX(this Transform value, float threshold = 0) {        EventTriggerListener.Get(value.gameObject).onDown = data => {            var filp = value.transform.localScale.x < 0;            var btn = value.GetComponent<Button>();            if (btn == null) {                value.transform.DOScale(filp ? -0.9f - threshold : 0.9f + threshold, 0.08f);            }            else if (btn != null && btn.enabled) {                if (btn.interactable)                    value.transform.DOScale(filp ? -0.9f - threshold : 0.9f + threshold, 0.08f);            }            else value.transform.DOScale(filp ? -0.9f - threshold : 0.9f + threshold, 0.08f);        };        EventTriggerListener.Get(value.gameObject).onUp = data => {            var filp = value.transform.localScale.x < 0;            var tweeen = DOTween.TweensByTarget(value);            var btn = value.GetComponent<Button>();            if (btn == null || btn != null && btn.enabled && btn.interactable) {                if (tweeen != null) DOTween.Kill(value, true);                value.DOScale(filp ? -1 : 1f, 0.1f);            }        };    }    public static bool IsMultipleLine(this Text tex) {        string strText = tex.text;        tex.text = "";        float linrHeight = tex.preferredHeight;        tex.text = strText;        return tex.preferredHeight > linrHeight;    }    public static void SetMaterialRenderingMode(this Material material, RenderingMode renderingMode) {        switch (renderingMode) {            case RenderingMode.Opaque:                material.SetInt("_SrcBlend", (int) UnityEngine.Rendering.BlendMode.One);                material.SetInt("_DstBlend", (int) UnityEngine.Rendering.BlendMode.Zero);                material.SetInt("_ZWrite", 1);                material.DisableKeyword("_ALPHATEST_ON");                material.DisableKeyword("_ALPHABLEND_ON");                material.DisableKeyword("_ALPHAPREMULTIPLY_ON");                material.renderQueue = -1;                break;            case RenderingMode.Cutout:                material.SetInt("_SrcBlend", (int) UnityEngine.Rendering.BlendMode.One);                material.SetInt("_DstBlend", (int) UnityEngine.Rendering.BlendMode.Zero);                material.SetInt("_ZWrite", 1);                material.EnableKeyword("_ALPHATEST_ON");                material.DisableKeyword("_ALPHABLEND_ON");                material.DisableKeyword("_ALPHAPREMULTIPLY_ON");                material.renderQueue = 2450;                break;            case RenderingMode.Fade:                material.SetInt("_SrcBlend", (int) UnityEngine.Rendering.BlendMode.SrcAlpha);                material.SetInt("_DstBlend", (int) UnityEngine.Rendering.BlendMode.OneMinusSrcAlpha);                material.SetInt("_ZWrite", 0);                material.DisableKeyword("_ALPHATEST_ON");                material.EnableKeyword("_ALPHABLEND_ON");                material.DisableKeyword("_ALPHAPREMULTIPLY_ON");                material.renderQueue = 3000;                break;            case RenderingMode.Transparent:                material.SetInt("_SrcBlend", (int) UnityEngine.Rendering.BlendMode.One);                material.SetInt("_DstBlend", (int) UnityEngine.Rendering.BlendMode.OneMinusSrcAlpha);                material.SetInt("_ZWrite", 0);                material.DisableKeyword("_ALPHATEST_ON");                material.DisableKeyword("_ALPHABLEND_ON");                material.EnableKeyword("_ALPHAPREMULTIPLY_ON");                material.renderQueue = 3000;                break;        }    }    public static Tweener DOEmissionColor(this Material target, Color endValue, float duration) {        return DOTween.To(() => target.GetColor("_Emission"), x => target.SetColor("_Emission", x), endValue, duration).SetTarget(target);    }    public static Tweener DOColorAlpha(this Material target, float endValue, float duration) {        return DOTween.To(() => target.GetColor("_Color").a, x => target.SetColor("_Color", new Color(1, 1, 1, x)), endValue, duration).SetTarget(target);    }    public static string Replace(this string str, int index, int removeNum, string value) {        str = str.Remove(index, removeNum);        str = str.Insert(index, value);        return str;    }    /// <summary>    /// 横向或纵向等距排布自身的子节点，且子节点同宽或同高    /// </summary>    public static void ArrangeChildren(this GameObject gameObject, float value = 0, bool horizontal = true) {        if (gameObject == null)            Debug.LogError("gameObject == null！排列子节点失败！");        else            ArrangeChildren(gameObject.transform, value, horizontal);    }    /// <summary>    /// 横向或纵向等距排布自身的子节点，且子节点同宽或同高    /// </summary>    public static void ArrangeChildren(this Transform transform, float value = 0, bool horizontal = true) {        if (transform == null)            Debug.LogError("transform == null！排列子节点失败！");        else {            int count = transform.childCount;            int half = (int) (count * 0.5f);            if (horizontal) {                if (value == 0) value = transform.RectTransform().rect.width;                float hw = value / 2;                float cw = transform.GetChild(0).RectTransform().rect.width;                float f = value - cw * count;                float spacing = f / (count + 1);                for (int i = 0; i < half; i++) {                    float x = hw - (spacing * (i + 1) + cw * (i + 0.5f));                    var tf1 = transform.GetChild(i);                    tf1.localPosition = new Vector3(-x, tf1.localPosition.y, tf1.localPosition.z);                    var tf2 = transform.GetChild(count - 1 - i);                    tf2.localPosition = new Vector3(x, tf2.localPosition.y, tf2.localPosition.z);                }                if (count % 2 == 1) {                    var tf = transform.GetChild(half + count > 1 ? 1 : 0);                    tf.localPosition = new Vector3(0f, tf.localPosition.y, tf.localPosition.z);                }            }            else {                if (value == 0) value = transform.RectTransform().rect.height;                float hh = value / 2;                float ch = transform.GetChild(0).RectTransform().rect.height;                float f = value - ch * count;                float spacing = f / (count + 1);                for (int i = 0; i < half; i++) {                    float y = hh - (spacing * (i + 1) + ch * (i + 0.5f));                    var tf1 = transform.GetChild(i);                    tf1.localPosition = new Vector3(tf1.localPosition.x, y, tf1.localPosition.z);                    var tf2 = transform.GetChild(i);                    tf2.localPosition = new Vector3(tf1.localPosition.x, -y, tf1.localPosition.z);                }                if (count % 2 == 1) {                    var tf = transform.GetChild(half + count > 1 ? 1 : 0);                    tf.localPosition = new Vector3(tf.localPosition.x, 0, tf.localPosition.z);                }            }        }    }    /// <summary>    /// 横纵向等距排列所有子节点；horizontalMax: 横向最大子节点数    /// </summary>    /// <param name="transform"></param>    /// <param name="horizontalMax"></param>    public static void ArrangeChildren(this Transform transform, int horizontalMax, float spacingW = 0, float spacingH = 0) {        if (transform == null)            Debug.LogError("transform == null！排列子节点失败！");        else {            if (horizontalMax == 1)                transform.ArrangeChildren(0, false);            else if (horizontalMax <= transform.childCount)                transform.ArrangeChildren();            else {                int verticalMax = transform.childCount / horizontalMax;                if (transform.childCount % horizontalMax != 0) verticalMax++;                var rectC = transform.GetChild(0).RectTransform().rect;                var rectP = new Rect(transform.RectTransform().rect);                bool bw = spacingW != 0;                if (spacingW != 0)                    rectP.width = horizontalMax * rectC.width + (horizontalMax + 1) * spacingW;                else                    spacingW = (rectP.width - rectC.width * horizontalMax) / (horizontalMax + 1);                bool bh = spacingH != 0;                if (spacingH != 0)                    rectP.height = verticalMax * rectC.width + (verticalMax + 1) * spacingW;                else                    spacingH = (rectP.width - rectC.width * verticalMax) / (verticalMax + 1);                //是否需要重设父节点宽高                if (bw || bh)                    transform.RectTransform().sizeDelta = new Vector2(rectP.width, rectP.height);                for (int i = 0; i < verticalMax; i++) {                    float y = spacingH * (i + 1) - rectC.height * i;                    for (int j = 0; j < horizontalMax; j++) {                        int idx = i + j;                        if (idx >= transform.childCount) break;                        var tf = transform.GetChild(idx);                        tf.RectTransform().anchorMin = Vector2.up;                        tf.RectTransform().anchorMax = Vector2.up;                        tf.RectTransform().pivot = Vector2.up;                        float x = spacingW * (i + 1) + rectC.width * i;                        tf.localPosition = new Vector3(x, y, tf.localPosition.z);                    }                }            }        }    }    public static void Show(this CanvasGroup canvasGroup, float time) {        if (canvasGroup != null) {            canvasGroup.gameObject.SetActive(true);            canvasGroup.alpha = 0;            canvasGroup.blocksRaycasts = false;            canvasGroup.DOFade(1f, time).OnComplete(() => { canvasGroup.blocksRaycasts = true; });        }    }    public static void Hide(this CanvasGroup canvasGroup, float time) {        if (canvasGroup != null) {            canvasGroup.alpha = 1f;            canvasGroup.blocksRaycasts = false;            canvasGroup.DOFade(0f, time).OnComplete(() => {                canvasGroup.blocksRaycasts = true;                canvasGroup.gameObject.SetActive(false);            });        }    }    public static void Fade(this CanvasGroup canvasGroup, float endValue, float time) {        if (canvasGroup != null) {            canvasGroup.blocksRaycasts = false;            canvasGroup.DOFade(endValue, time).OnComplete(() => { canvasGroup.blocksRaycasts = true; });        }    }    public static void SetInteractable(this Button button, bool interactable) {        button.interactable = interactable;        var tf = button.transform.Find("Image");        if (tf != null)            tf.GetComponent<Image>().color = interactable ? Color.white : new Color(0.7f, 0.7f, 0.7f, 0.5f);        //var images = button.transform.GetComponentsInChildren<Image>();        //if (images != null)        //{        //    for (int i = 0, count = images.Length; i < count; i++)        //    {        //        if (images[i] != null)        //            images[i].color = interactable ? Color.white : new Color(0.7f, 0.7f, 0.7f, 0.5f);        //    }        //}    }    /// <summary>    /// 通过计算所有子节点的高度和，设置自身高度    /// </summary>    public static void SetHeightByChild(this Transform parent, float oh = 0) {        var rect = parent.GetComponent<RectTransform>();        float w = rect.sizeDelta.x;        float h = 0f;        foreach (Transform child in parent) {            float y = child.RectTransform().sizeDelta.y;            var text = child.GetComponent<Text>();            if (text != null)                y = text.preferredHeight;            h += y;        }        rect.sizeDelta = new Vector2(w, h + oh);    }    /// <summary>    /// 通过计算所有子节点的高度和，设置自身高度    /// </summary>    public static void SetHeightByChild(this GameObject parent, float oh = 0) {        SetHeightByChild(parent.transform, oh);    }    /// <summary>    /// 通过计算所有子节点的宽度和，设置自身宽度    /// </summary>    public static void SetWidthByChild(this Transform parent, float ow = 0) {        var rect = parent.GetComponent<RectTransform>();        float w = 0f;        float h = rect.sizeDelta.y;        foreach (Transform child in parent) {            float x = child.RectTransform().sizeDelta.x;            var text = child.GetComponent<Text>();            if (text != null)                x = text.preferredWidth;            w += x;        }        rect.sizeDelta = new Vector2(w + ow, h);    }    /// <summary>    /// 通过计算所有子节点的宽度和，设置自身宽度    /// </summary>    public static void SetWidthByChild(this GameObject parent, float ow = 0) {        SetWidthByChild(parent.transform, ow);    }    /// <summary>    /// 计算字符串中子串出现的次数    /// </summary>    /// <param name="str">字符串</param>    /// <param name="substring">子串</param>    /// <returns>出现的次数</returns>    public static int SubstringCount(this string str, string substring) {        if (str.Contains(substring)) {            string strReplaced = str.Replace(substring, "");            return (str.Length - strReplaced.Length) / substring.Length;        }        return 0;    }    public static void ResetState(this Animation ani, string animation) {        ani.Play(animation);        ani[animation].time = 0f;        ani.Sample();        ani[animation].enabled = false;    }    /// <summary>    /// 根据限定宽度，调整文字大小    /// </summary>    /// <param name="text">文本实例</param>    /// <param name="maxWidth">限定的最大宽度</param>    /// <param name="standard">基准值，每超出限定宽度一个standard，字体大小减少一个size</param>    /// <param name="size">基准值对应的减少的具体的字体大小</param>    public static void SetFontsize(this Text text, float maxWidth, float standard, int size) {        float value = text.preferredWidth - maxWidth;        if (value > 0) {            value = value / standard + 1;            int fs = text.fontSize - size * (int) value;            text.fontSize = fs < 24 ? 24 : fs;        }    }    public static string GetItemString(this Dictionary<string, string> dict) {        return dict.Keys.Aggregate("", (current, key) => current + $"{key}: {dict[key]}; ");    }    public static List<T> NoDuplicates<T>(this List<T> sourceCollection) {        return sourceCollection.Where((x, i) => sourceCollection.FindIndex(z => z.Equals(x)) == i).ToList();    }    public static void RemoveAll<K, V>(this IDictionary<K, V> dict, Func<K, V, bool> match) {        foreach (var key in dict.Keys.ToArray().Where(key => match(key, dict[key])))            dict.Remove(key);    }    /// <summary>    /// 判断两个集合是否是相等的(所有的元素及数量都相等)    /// </summary>    /// <typeparam name="T">集合元素类型</typeparam>    /// <param name="sourceCollection">源集合列表</param>    /// <param name="targetCollection">目标集合列表</param>    /// <returns>两个集合相等则返回True,否则返回False</returns>    public static bool EqualList<T>(this IList<T> sourceCollection, IList<T> targetCollection) where T : IEquatable<T> {        //空集合直接返回False,即使是两个都是空集合,也返回False        if (sourceCollection == null || targetCollection == null) {            return false;        }        if (object.ReferenceEquals(sourceCollection, targetCollection)) {            return true;        }        if (sourceCollection.Count != targetCollection.Count) {            return false;        }        var sourceCollectionStaticsDict = sourceCollection.StatisticRepetition();        var targetCollectionStaticsDict = targetCollection.StatisticRepetition();        return sourceCollectionStaticsDict.EqualDictionary(targetCollectionStaticsDict);    }    /// <summary>    /// 判断两个字典是否是相等的(所有的字典项对应的值都相等)    /// </summary>    /// <typeparam name="TKey">字典项类型</typeparam>    /// <typeparam name="TValue">字典值类型</typeparam>    /// <param name="sourceDictionary">源字典</param>    /// <param name="targetDictionary">目标字典</param>    /// <returns>两个字典相等则返回True,否则返回False</returns>    public static bool EqualDictionary<TKey, TValue>(this Dictionary<TKey, TValue> sourceDictionary, Dictionary<TKey, TValue> targetDictionary)        where TKey : IEquatable<TKey> where TValue : IEquatable<TValue> {        //空字典直接返回False,即使是两个都是空字典,也返回False        if (sourceDictionary == null || targetDictionary == null) {            return false;        }        if (object.ReferenceEquals(sourceDictionary, targetDictionary)) {            return true;        }        if (sourceDictionary.Count != targetDictionary.Count) {            return false;        }        //比较两个字典的Key与Value        foreach (var item in sourceDictionary) {            //如果目标字典不包含源字典任意一项,则不相等            if (!targetDictionary.ContainsKey(item.Key)) {                return false;            }            //如果同一个字典项的值不相等,则不相等            if (!targetDictionary[item.Key].Equals(item.Value)) {                return false;            }        }        return true;    }    /// <summary>    /// 统计集合的重复项,并返回一个字典    /// </summary>    /// <typeparam name="T">集合元素类型</typeparam>    /// <param name="sourceCollection">统计集合列表</param>    /// <returns>返回一个集合元素及重复数量的字典</returns>    private static Dictionary<T, int> StatisticRepetition<T>(this IEnumerable<T> sourceCollection) where T : IEquatable<T> {        var collectionStaticsDict = new Dictionary<T, int>();        foreach (var item in sourceCollection) {            if (collectionStaticsDict.ContainsKey(item)) {                collectionStaticsDict[item]++;            }            else {                collectionStaticsDict.Add(item, 1);            }        }        return collectionStaticsDict;    }    public static void Draw(this Bounds bounds, Color color) {        var e = bounds.extents;        Debug.DrawLine(bounds.center + new Vector3(+e.x, +e.y, +e.z), bounds.center + new Vector3(-e.x, +e.y, +e.z), color);        Debug.DrawLine(bounds.center + new Vector3(+e.x, -e.y, +e.z), bounds.center + new Vector3(-e.x, -e.y, +e.z), color);        Debug.DrawLine(bounds.center + new Vector3(+e.x, -e.y, -e.z), bounds.center + new Vector3(-e.x, -e.y, -e.z), color);        Debug.DrawLine(bounds.center + new Vector3(+e.x, +e.y, -e.z), bounds.center + new Vector3(-e.x, +e.y, -e.z), color);        Debug.DrawLine(bounds.center + new Vector3(+e.x, +e.y, +e.z), bounds.center + new Vector3(+e.x, -e.y, +e.z), color);        Debug.DrawLine(bounds.center + new Vector3(-e.x, +e.y, +e.z), bounds.center + new Vector3(-e.x, -e.y, +e.z), color);        Debug.DrawLine(bounds.center + new Vector3(-e.x, +e.y, -e.z), bounds.center + new Vector3(-e.x, -e.y, -e.z), color);        Debug.DrawLine(bounds.center + new Vector3(+e.x, +e.y, -e.z), bounds.center + new Vector3(+e.x, -e.y, -e.z), color);        Debug.DrawLine(bounds.center + new Vector3(+e.x, +e.y, +e.z), bounds.center + new Vector3(+e.x, +e.y, -e.z), color);        Debug.DrawLine(bounds.center + new Vector3(+e.x, -e.y, +e.z), bounds.center + new Vector3(+e.x, -e.y, -e.z), color);        Debug.DrawLine(bounds.center + new Vector3(-e.x, +e.y, +e.z), bounds.center + new Vector3(-e.x, +e.y, -e.z), color);        Debug.DrawLine(bounds.center + new Vector3(-e.x, -e.y, +e.z), bounds.center + new Vector3(-e.x, -e.y, -e.z), color);    }    public static T PickRandom<T>(this ICollection<T> collection) {        int index = UnityEngine.Random.Range(0, collection.Count);        return collection.ElementAt(index);    }    public static LuaTable ToLuaTable(this Dictionary<string, string> jo) {        if (jo == null) return null;        var table = (LuaTable) LuaEnvironment.luaEnv.Global.Get<LuaFunction>("newT").Call()[0];        foreach (var j in jo) {            table.Set(j.Key, j.Value);        }        return table;    }    public static void DeleteChildren(this Transform transform) {        int c = 0;        while (transform.childCount != 0) {            GameObject.DestroyImmediate(transform.GetChild(0).gameObject);            if (c++ > 10000) {                throw new System.Exception();            }        }    }    public static T GetBest<T>(this IEnumerable<T> enumerable, Func<T, float> property) {        float bestValue = float.NegativeInfinity;        T bestItem = default(T);        foreach (var item in enumerable) {            float value = property.Invoke(item);            if (value > bestValue) {                bestValue = value;                bestItem = item;            }        }        return bestItem;    }    public static bool Contains<T>(this T[] array, T value) {        return Array.IndexOf(array, value) > -1;    }}